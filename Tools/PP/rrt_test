import pygame
import random
import math

# Initialize Pygame
pygame.init()
screen_width = 800
screen_height = 600
screen = pygame.display.set_mode((screen_width, screen_height))
clock = pygame.time.Clock()


# Define parameters and obstacles
obstacles = [(150,100), (260,220)]
start_pos = (50,50)
goal_pos = (510,510)
safety_distance = 20 

class RRT:
    def __init__(self, start_pos, goal_pos, obstacles, safety_distance):
        self.start_pos = start_pos
        self.goal_pos = goal_pos
        self.obstacles = obstacles
        self.safety_distance = safety_distance
        self.nodes = [start_pos]  # List of nodes in the RRT
        self.path = []

    def sample_point(self):
        if random.random() < 0.8:  # 80% chance for random point
            return (random.uniform(0, screen_width), random.uniform(0, screen_height))
        else:  # 20% chance for goal bias
            return self.goal_pos

    def nearest_neighbor(self, point):
        nearest_node = self.nodes[0]
        nearest_dist = math.inf
        for node in self.nodes:
            dist = math.hypot(point[0] - node[0], point[1] - node[1])
            if dist < nearest_dist:
                nearest_node = node
                nearest_dist = dist
        return nearest_node

    def extend(self, nearest_node, sampled_point):
        step_size = 10 
        new_node = (
            nearest_node[0] + step_size * (sampled_point[0] - nearest_node[0]) / math.hypot(
                sampled_point[0] - nearest_node[0], sampled_point[1] - nearest_node[1]
            ),
            nearest_node[1] + step_size * (sampled_point[1] - nearest_node[1]) / math.hypot(
                sampled_point[0] - nearest_node[0], sampled_point[1] - nearest_node[1]
            ),
        )

        if not self.check_collision(nearest_node, new_node):
            self.nodes.append(new_node)
            return True
        else:
            return False

    def check_collision(self, node1, node2):
      for obstacle in self.obstacles:
          # Check collision with obstacle's circle
        if math.hypot(node1[0] - obstacle[0], node1[1] - obstacle[1]) < self.safety_distance:
            return True
        if math.hypot(node2[0] - obstacle[0], node2[1] - obstacle[1]) < self.safety_distance:
            return True

        # Check collision with obstacle's edges (for rectangular obstacles)
        if isinstance(obstacle, tuple):  # Assuming rectangular obstacles are represented as tuples
            obstacle_x, obstacle_y, obstacle_width, obstacle_height = obstacle
            if (
                node1[0] > obstacle_x
                and node1[0] < obstacle_x + obstacle_width
                and node1[1] > obstacle_y
                and node1[1] < obstacle_y + obstacle_height
            ) or (
                node2[0] > obstacle_x
                and node2[0] < obstacle_x + obstacle_width
                and node2[1] > obstacle_y
                and node2[1] < obstacle_y + obstacle_height
            ):
                return True

        # Check collision with the path itself (for smoothness)
        for i in range(1, len(self.nodes) - 1):
            if self.line_intersect(node1, node2, self.nodes[i], self.nodes[i + 1]):
                return True
            
      return False  # No collision detected
    def get_path_coordinates(self):
      if self.path is None:
        return []  # No path found yet
      path_coordinates = []
      for node in self.path:
        path_coordinates.append((node[0], node[1]))
      return path_coordinates

    def backtrack_path(self, node):
        path = [node]
        while node != self.start_pos:
            for parent in self.nodes:
                if math.hypot(node[0] - parent[0], node[1] - parent[1]) < 10:  # Adjust threshold
                    node = parent
                    path.append(node)
                    break
        path.reverse()
        return path

def main():
    rrt = RRT(start_pos, goal_pos, obstacles, safety_distance)
    path_found = False

    while not path_found:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                exit()

        new_node = rrt.sample_point()
        nearest_node = rrt.nearest_neighbor(new_node)

        if rrt.extend(nearest_node, new_node):
            if new_node == goal_pos:
                path_found = True
                path = rrt.backtrack_path(new_node)
                print(path)

        screen.fill((255, 255, 255))

        for obstacle in obstacles:
            pygame.draw.circle(screen, (0, 0, 0), obstacle, safety_distance)

        if path_found:
            for i in range(len(path) - 1):
                pygame.draw.line(screen, (0, 255, 0), path[i], path[i + 1], 5)

            pygame.draw.circle(screen, (255, 0, 0), start_pos, 10)
            pygame.draw.circle(screen, (0, 0, 255), goal_pos, 10)

        for node in rrt.nodes:
            pygame.draw.circle(screen, (128, 128, 128), node, 5)

        pygame.display.flip()
        pygame.display.update()
        clock.tick(60)  # Adjust the frame rate
