import cv2
import cv2.aruco as aruco
import numpy as np

x_aruco, y_aruco,marker_length, mapx, mapy = 0.57, 0.575, 0.1 , 1.998, 2.998

calib_data_path = r"Vision\\calibration\\Calib_matrix\\MultiMatrixXiaomi.npz"
img_path = r"Vision\\test_images\\WhatsApp Image 2023-12-08 at 17.28.20.jpeg"

#marker_locations_3d = {
    20: np.array([(x_aruco-marker_length, y_aruco-marker_length, 0),
                    (x_aruco+marker_length, y_aruco-marker_length, 0),
                      (x_aruco+marker_length, y_aruco+marker_length, 0),
                        (x_aruco-marker_length, y_aruco+marker_length, 0)]),
    21: np.array([(mapx-x_aruco-marker_length, y_aruco-marker_length, 0),
                   (mapx-x_aruco+marker_length, y_aruco-marker_length, 0),
                     (mapx-x_aruco+marker_length, y_aruco+marker_length, 0),
                       (mapx-x_aruco-marker_length, y_aruco+marker_length, 0)]),
    22: np.array([(x_aruco-marker_length, mapy-y_aruco-marker_length, 0),
                   (x_aruco+marker_length, mapy-y_aruco-marker_length, 0),
                     (x_aruco+marker_length, mapy-y_aruco+marker_length, 0),
                       (x_aruco, mapy-y_aruco+marker_length, 0)]),
    23: np.array([(mapx-x_aruco-marker_length, mapy-y_aruco-marker_length, 0),
                   (mapx-x_aruco+marker_length, mapy-y_aruco-marker_length, 0),
                     (mapx-x_aruco+marker_length, mapy-y_aruco+marker_length, 0),
                       (mapx-x_aruco-marker_length, mapy-y_aruco+marker_length, 0)])
}

def load_calibration_data(calib_data_path):
    calib_data = np.load(calib_data_path)
    camera_matrix = calib_data['camMatrix']
    dist_coeffs = calib_data['distCoef']
    return camera_matrix, dist_coeffs

def detect_markers(img, marker_dict=aruco.getPredefinedDictionary(aruco.DICT_4X4_50), aruco_params=aruco.DetectorParameters()):
    return aruco.detectMarkers(img, marker_dict, parameters=aruco_params)



def get_homography(image_points, object_points):
    homography_matrix, _ = cv2.findHomography(object_points[:, :2], image_points)
    return homography_matrix

def warp_image(img, homography_matrix, size):
    img_top_down = cv2.warpPerspective(img, homography_matrix, size)
    return img_top_down


def get_marker_locations_3d(x_aruco, y_aruco, marker_length, mapx, mapy):
    # Define marker locations in 3D space (assuming they lie on the z=0 plane)
    marker_locations_3d = {
        20: np.array([(x_aruco - marker_length/2, y_aruco - marker_length/2, 0),
                      (x_aruco + marker_length/2, y_aruco - marker_length/2, 0),
                      (x_aruco + marker_length/2, y_aruco + marker_length/2, 0),
                      (x_aruco - marker_length/2, y_aruco + marker_length/2, 0)]),

        21: np.array([(mapx - x_aruco - marker_length/2, y_aruco - marker_length/2, 0),
                      (mapx - x_aruco + marker_length/2, y_aruco - marker_length/2, 0),
                      (mapx - x_aruco + marker_length/2, y_aruco + marker_length/2, 0),
                      (mapx - x_aruco - marker_length/2, y_aruco + marker_length/2, 0)]),

        22: np.array([(x_aruco - marker_length/2, mapy - y_aruco - marker_length/2, 0),
                      (x_aruco + marker_length/2, mapy - y_aruco - marker_length/2, 0),
                      (x_aruco + marker_length/2, mapy - y_aruco + marker_length/2, 0),
                      (x_aruco - marker_length/2, mapy - y_aruco + marker_length/2, 0)]),

        23: np.array([(mapx - x_aruco - marker_length/2, mapy - y_aruco - marker_length/2, 0),
                      (mapx - x_aruco + marker_length/2, mapy - y_aruco - marker_length/2, 0),
                      (mapx - x_aruco + marker_length/2, mapy - y_aruco + marker_length/2, 0),
                      (mapx - x_aruco - marker_length/2, mapy - y_aruco + marker_length/2, 0)])
    }
    return marker_locations_3d

def load_image_and_onject_points(corners):
     image_points, object_points = [], []
    
    image_points.append(corners[i][0])


def process_image(img_path, calib_data_path):
    camera_matrix, dist_coeffs = load_calibration_data(calib_data_path)
    img = cv2.imread(img_path)
    #img_undistorted = cv2.undistort(img, camera_matrix, dist_coeffs, None, camera_matrix)

    marker_dict = aruco.getPredefinedDictionary(aruco.DICT_4X4_50)
    aruco_params = aruco.DetectorParameters()
    

    corners, ids, rejected = detect_markers(img, marker_dict, aruco_params)
    

    marker_locations_3d = get_marker_locations_3d(x_aruco, y_aruco, marker_length, mapx, mapy)
    image_points, object_points = [], []

    if ids is not None and len(ids) == 4 :
        for i, marker_id in enumerate(ids.flatten()):
            if marker_id in marker_locations_3d:
                image_points.append(corners[i][0])
                object_points.append(marker_locations_3d[marker_id])
    if len(ids) != 4 : 
        print("cant detect enough aruco tags im detecing only {ids} ")
    

    if len(image_points) >= 4:
        homography_matrix = get_homography(np.array(image_points).reshape(-1, 2), 
                                           np.array(object_points).reshape(-1, 3))
        img_top_down = warp_image(img, homography_matrix, (img.shape[1], img.shape[0]))
        return img_top_down, img
    else:
        print("Not enough markers detected to compute the homography matrix.")
        return None, None

def main():
    
    img_top_down, marked_img = process_image(img_path, calib_data_path)
    
    if img_top_down is not None:
        cv2.imshow('Top-Down View', img_top_down)
        cv2.imshow('Marked Image', marked_img)
        cv2.waitKey(0)
        cv2.destroyAllWindows()

if __name__ == "__main__":
    main()
