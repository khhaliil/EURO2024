import cv2
import cv2.aruco as aruco
import numpy as np
from save_data import save_frame
from save_data import Calculate_homography
from save_data import pixel_to_mm
import os 


# Load calibration data from .npz file
calib_data_path = r"Vision\calibration\Calib_matrix\MultiMatrixXiaomi.npz"
calib_data = np.load(calib_data_path)
cameraMatrix = calib_data['camMatrix']
distCoeffs = calib_data['distCoef']

Calculate_homography_manually = False
homography_calculated= False
homography_matrix_path = r"C:\Users\MSI\Desktop\EURO2024\Tools\homography_matrix.npz"

def load_homography_matrix(path):
    if os.path.exists(path):
        data = np.load(path)
        return data['homography_matrix']
    else:
        return None

homography_matrix = load_homography_matrix(homography_matrix_path)
print(homography_matrix)
map_corners_3d = np.float32([[0, 0], [2, 0], [2, 3], [0, 3]])

global capture_mode
capture_mode = False

bird_view_done= False
# Set the mouse callback function for your top_down window
cv2.namedWindow('Top-Down View')

def click_event(event, x, y, flags, param):
    global capture_mode
    if event == cv2.EVENT_LBUTTONDOWN and capture_mode:
        captured_x, captured_y = x, y
        print(pixel_to_mm(captured_x,captured_y))
        #real_x, real_y = pixel_to_real(captured_x, captured_y, scale_factor, x_offset, y_offset)
        print(f"Captured pixel coordinates: {captured_x}, {captured_y}")
        #print(f"Converted real-world coordinates: {real_x} mm, {real_y} mm")
        capture_mode = False

cv2.setMouseCallback('Top-Down View', click_event)

mapx = 2
mapy = 3
cap = cv2.VideoCapture(2)
cv2.namedWindow("Trackbars")

def nothing(x):
    pass
# Create trackbars for adjusting parameters
cv2.createTrackbar("Marker Length", "Trackbars", 10, 20, nothing)  # Range from 0.1m to 0.2m
cv2.createTrackbar("X Aruco", "Trackbars", 517, 1000, nothing)  # Example range
cv2.createTrackbar("Y Aruco", "Trackbars", 755, 1000, nothing)

while True : 

    ret,img = cap.read()
    if not ret :
        break 

    img = cv2.flip(img, -1)
    img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

    img_top_down = img

    if homography_calculated == False:
        # print("entered loop")
        if homography_matrix is None or Calculate_homography_manually == True:
            homography_matrix = Calculate_homography(img)
            # print("hhnfdj",homography_matrix)
            if homography_matrix is not None:
                Calculate_homography_manually = not Calculate_homography_manually
                homography_calculated = True
            else:
                print("Homography matrix calculation failed")
        else:
            print("loaded homography matrix from local")
            # Only proceed if homography_matrix is valid
    if homography_matrix is not None and not bird_view_done:
        try:
            map_corners_2d = cv2.perspectiveTransform(map_corners_3d.reshape(-1, 1, 2), homography_matrix)
                    # ... [rest of the code to process map_corners_2d and create img_top_down]
        except cv2.error as e:
            print(f"Error in perspective transform: {e}")
        #print (map_corners_2d)
    # Draw the projected corners on the image
        points = []
        for i in range(map_corners_2d.shape[0]):
            point = tuple(map_corners_2d[i, 0].astype(int))
            points.append(point)
        #cv2.circle(img, point, 10, (0, 255, 0), -1)
        #cv2.putText(img,str(i),point,cv2.FONT_HERSHEY_COMPLEX,1,(0, 255, 0),2)
        #print(img.shape)
        src_pts = np.array([points[1],points[0],  points[2], points[3]], dtype='float32')
        dst_pts = np.array([[0,0],[ 0,img.shape[0]],  [img.shape[1], 0], [ img.shape[1],img.shape[0]]], dtype='float32')
        M = cv2.getPerspectiveTransform(src_pts, dst_pts)
 # Warp the image to get the top-down view
        
        homography_calculated = True
        bird_view_done= not bird_view_done
    
    img_top_down = cv2.warpPerspective(img, M, (img.shape[1], img.shape[0]))
    cv2.imshow('Top-Down View', img_top_down)
    cv2.imshow('Marked Image', img)
    


    key = cv2.waitKey(1) & 0xFF
    if key == ord('s'):
        # Manual save
        save_frame(img_top_down, prefix='top_down', manual_save=True)
    else:
        # Automatic save every 10 seconds
        save_frame(img_top_down, prefix='top_down', interval=12)
    if key == ord('g'):
            # Toggle capture mode
        capture_mode = not capture_mode
        if capture_mode:
            print("Capture mode activated. Click on the desired pixel.")
        else:
            print("Capture mode deactivated.")
    if key == ord('h'):
        # Toggle the Calculate_homography_manually flag
        Calculate_homography_manually = not Calculate_homography_manually
        homography_calculated= False
        bird_view_done = not bird_view_done
        if Calculate_homography_manually:
            print("Manual homography calculation mode activated.")
        else:
            print("Manual homography calculation mode deactivated.")
        
   
cap.release()
cv2.destroyAllWindows()
