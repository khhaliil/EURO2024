import cv2
import cv2.aruco as aruco
import numpy as np
from save_data import save_frame
from save_data import Calculate_homography
from save_data import pixel_to_mm
from Kalman import get_measurements,predict_future_positions_kalman
import os 
import sys
sys.path.append(r'C:\Users\MSI\Desktop\EURO2024')  # Replace with the absolute path to EURO directory
###############################################################################
BLUE_TEAM_RANGE = [1, 5]
YELLOW_TEAM_RANGE = [6, 10]

color_to_track=YELLOW_TEAM_RANGE

def switch_team(team_color):
    global current_team_range
    if team_color.lower() == 'blue':
        current_team_range = BLUE_TEAM_RANGE
    elif team_color.lower() == 'yellow':
        current_team_range = YELLOW_TEAM_RANGE
    else:
        print(f"Unknown team color: {team_color}")

###############################################################################

# calib_data_path = r"Vision\calibration\Calib_matrix\MultiMatrixXiaomi.npz"
# calib_data = np.load(calib_data_path)
# cameraMatrix = calib_data['camMatrix']
# distCoeffs = calib_data['distCoef']

marker_dict = aruco.getPredefinedDictionary(aruco.DICT_4X4_250)
aruco_params = aruco.DetectorParameters()

Calculate_homography_manually = False
homography_calculated= False
homography_matrix_path = r"C:\Users\MSI\Desktop\EURO2024\Tools\homography_matrix.npz"

def load_homography_matrix(path):
    try:
        with np.load(path) as data:
            return data['homography_matrix']
    except KeyError:
        print(f"'homography_matrix' not found in {path}")
        return None
    except IOError:
        print(f"Could not read file: {path}")
        return None

homography_matrix = load_homography_matrix(homography_matrix_path)
print(homography_matrix)
map_corners_3d = np.float32([[0, 0], [2, 0], [2, 3], [0, 3]])

global capture_mode
capture_mode = False

bird_view_done= False
# Set the mouse callback function for your top_down window
cv2.namedWindow('Top-Down View')

def click_event(event, x, y, flags, param):
    global capture_mode
    if event == cv2.EVENT_LBUTTONDOWN and capture_mode:
        captured_x, captured_y = x, y
        print(pixel_to_mm(captured_x,captured_y))
        #real_x, real_y = pixel_to_real(captured_x, captured_y, scale_factor, x_offset, y_offset)
        print(f"Captured pixel coordinates: {captured_x}, {captured_y}")
        #print(f"Converted real-world coordinates: {real_x} mm, {real_y} mm")
        capture_mode = False

cv2.setMouseCallback('Top-Down View', click_event)

mapx = 2
mapy = 3
cap = cv2.VideoCapture(3)
cv2.namedWindow("Trackbars")

def nothing(x):
    pass

# Create trackbars for adjusting parameters
cv2.createTrackbar("Marker Length", "Trackbars", 10, 20, nothing)  # Range from 0.1m to 0.2m
cv2.createTrackbar("X Aruco", "Trackbars", 516, 1000, nothing)  # Example range
cv2.createTrackbar("Y Aruco", "Trackbars", 755, 1000, nothing)

while True : 

    ret,img = cap.read()
    if not ret :
        break 
    
    #img = cv2.flip(img, -1)
    #img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

    img_top_down = img



    if homography_calculated == False:
        if homography_matrix is None or Calculate_homography_manually == True:
            corners, ids, rejected = aruco.detectMarkers(img, marker_dict, parameters=aruco_params)
            homography_matrix = Calculate_homography(corners,ids,img)
            # print("hhnfdj",homography_matrix)
            if homography_matrix is not None:
                Calculate_homography_manually = not Calculate_homography_manually
                homography_calculated = True
            else:
                print("Homography matrix calculation failed")
        else:
            print("loaded homography matrix from local")
            homography_calculated = True
            
    if homography_matrix is not None and not bird_view_done:
        try:
            map_corners_2d = cv2.perspectiveTransform(map_corners_3d.reshape(-1, 1, 2), homography_matrix)
                   
        except cv2.error as e:
            print(f"Error in perspective transform: {e}")
        #print (map_corners_2d)
    # Draw the projected corners on the image
        points = []
        for i in range(map_corners_2d.shape[0]):
            point = tuple(map_corners_2d[i, 0].astype(int))
            points.append(point)
        #cv2.circle(img, point, 10, (0, 255, 0), -1)
        #cv2.putText(img,str(i),point,cv2.FONT_HERSHEY_COMPLEX,1,(0, 255, 0),2)
        #print(img.shape)
        src_pts = np.array([points[1],points[0],  points[2], points[3]], dtype='float32')
        dst_pts = np.array([[0,0],[ 0,img.shape[0]],  [img.shape[1], 0], [ img.shape[1],img.shape[0]]], dtype='float32')
        M = cv2.getPerspectiveTransform(src_pts, dst_pts)
 # Warp the image to get the top-down view
        
        homography_calculated = True
        bird_view_done= not bird_view_done
    
  
    ennemy_robot_predictions = []   
    img_top_down = cv2.warpPerspective(img, M, (img.shape[1], img.shape[0]))

    get_measurements(img_top_down,color_to_track=color_to_track)
    current_positions, ennemy_robot_predictions = predict_future_positions_kalman()
    if current_positions is not None:
    # Draw the current position
        cv2.circle(img_top_down, (int(current_positions[0]), int(current_positions[1])), 5, (255, 0, 255), -1)
    #print(ennemy_robot_predictions)
    # Draw circles for each future position if predictions are available
    if ennemy_robot_predictions is not None:
        for pos in ennemy_robot_predictions:
            x, y = int(pos[0]), int(pos[1])
            cv2.circle(img_top_down, (x, y), 4, (0, 0, 255), -1)
    
    cv2.imshow('Top-Down View', img_top_down)
    cv2.imshow('Marked Image', img)
    


    key = cv2.waitKey(1) & 0xFF
    if key == ord('s'):
        # Manual save
        save_frame(img_top_down, prefix='top_down', manual_save=True)
    else:
        # Automatic save every 10 seconds
        
        save_frame(img_top_down, prefix='top_down', interval=12)
    if key == ord('g'):
            # Toggle capture mode
        capture_mode = not capture_mode
        if capture_mode:
            print("Capture mode activated. Click on the desired pixel.")
        else:
            print("Capture mode deactivated.")
    if key == ord('h'):
        # Toggle the Calculate_homography_manually flag
        Calculate_homography_manually = not Calculate_homography_manually
        homography_calculated= False
        bird_view_done = not bird_view_done
        if Calculate_homography_manually:
            print("Manual homography calculation mode activated.")
        else:
            print("Manual homography calculation mode deactivated.")
        
   
cap.release()
cv2.destroyAllWindows()
